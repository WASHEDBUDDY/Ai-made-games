<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Endless Stealth - Mobile</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Prevents scrolling while playing */
        }

        #ui-layer {
            width: 90%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
        }

        #gameCanvas {
            background: #222;
            border: 2px solid #444;
            max-width: 95vw;
            max-height: 70vh;
            touch-action: none;
        }

        #status { color: #0f0; }
        
        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            text-align: center;
            border: 1px solid #555;
            display: none;
            z-index: 100;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>SCORE: <span id="scoreVal">0</span></div>
        <div>LVL: <span id="levelVal">1</span></div>
        <div id="status">SNEAK!</div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="gameOverScreen" class="overlay">
        <h1 style="color: #f00;">DETECTED!</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame(true)">TRY AGAIN</button>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreVal');
    const levelEl = document.getElementById('levelVal');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');

    let gameActive = true;
    let score = 0;
    let level = 1;
    let keys = {};

    const player = { x: 50, y: 50, size: 15, speed: 3.5, color: '#00ccff' };
    const goal = { x: 750, y: 550, size: 40, color: '#00ff00' };
    let enemies = [];

    // --- Touch/Joystick State ---
    let joystick = {
        active: false,
        startX: 0,
        startY: 0,
        currX: 0,
        currY: 0,
        maxDist: 50,
        moveX: 0,
        moveY: 0
    };

    // --- Input Handling ---
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    // Touch Events
    canvas.addEventListener('touchstart', e => {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        joystick.active = true;
        joystick.startX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        joystick.startY = (touch.clientY - rect.top) * (canvas.height / rect.height);
        joystick.currX = joystick.startX;
        joystick.currY = joystick.startY;
    });

    canvas.addEventListener('touchmove', e => {
        if (!joystick.active) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        joystick.currX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        joystick.currY = (touch.clientY - rect.top) * (canvas.height / rect.height);

        // Calculate normalized direction
        let dx = joystick.currX - joystick.startX;
        let dy = joystick.currY - joystick.startY;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0) {
            joystick.moveX = (dx / dist) * Math.min(dist / joystick.maxDist, 1);
            joystick.moveY = (dy / dist) * Math.min(dist / joystick.maxDist, 1);
        }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
        joystick.active = false;
        joystick.moveX = 0;
        joystick.moveY = 0;
    });

    function initLevel() {
        player.x = 40; player.y = 40;
        goal.x = canvas.width - 60;
        goal.y = Math.random() > 0.5 ? canvas.height - 60 : 60;
        enemies = [];
        for (let i = 0; i < 2 + level; i++) spawnEnemy();
    }

    function spawnEnemy() {
        let ex, ey;
        do {
            ex = Math.random() * (canvas.width - 100) + 50;
            ey = Math.random() * (canvas.height - 100) + 50;
        } while (getDistance(player.x, player.y, ex, ey) < 200);

        enemies.push({
            x: ex, y: ey, size: 15,
            angle: Math.random() * Math.PI * 2,
            speed: 1.2 + (level * 0.15),
            fov: Math.PI / 3.5,
            viewDist: 180 + (level * 5),
            color: '#ff3333'
        });
    }

    function getDistance(x1, y1, x2, y2) { return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2); }

    function update() {
        if (!gameActive) return;

        // Keyboard Movement
        if ((keys['w'] || keys['ArrowUp']) && player.y > 0) player.y -= player.speed;
        if ((keys['s'] || keys['ArrowDown']) && player.y < canvas.height) player.y += player.speed;
        if ((keys['a'] || keys['ArrowLeft']) && player.x > 0) player.x -= player.speed;
        if ((keys['d'] || keys['ArrowRight']) && player.x < canvas.width) player.x += player.speed;

        // Touch Movement
        if (joystick.active) {
            player.x += joystick.moveX * player.speed;
            player.y += joystick.moveY * player.speed;
        }

        // Keep player in bounds
        player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
        player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

        if (getDistance(player.x, player.y, goal.x + 20, goal.y + 20) < 35) {
            score += 100; level++;
            scoreEl.innerText = score; levelEl.innerText = level;
            initLevel();
        }

        enemies.forEach(enemy => {
            enemy.x += Math.cos(enemy.angle) * enemy.speed;
            enemy.y += Math.sin(enemy.angle) * enemy.speed;

            if (enemy.x < 20 || enemy.x > canvas.width - 20) enemy.angle = Math.PI - enemy.angle;
            if (enemy.y < 20 || enemy.y > canvas.height - 20) enemy.angle = -enemy.angle;

            if (Math.random() < 0.02) enemy.angle += (Math.random() - 0.5) * 1;

            let dx = player.x - enemy.x;
            let dy = player.y - enemy.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < enemy.viewDist) {
                let angleToPlayer = Math.atan2(dy, dx);
                let angleDiff = angleToPlayer - enemy.angle;
                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                if (Math.abs(angleDiff) < enemy.fov / 2) gameOver();
            }
            if (dist < player.size + enemy.size) gameOver();
        });
    }

    function draw() {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Goal
        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.fillRect(goal.x, goal.y, goal.size, goal.size);
        ctx.strokeStyle = '#0f0';
        ctx.strokeRect(goal.x, goal.y, goal.size, goal.size);

        // Enemies
        enemies.forEach(enemy => {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.15)';
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y);
            ctx.arc(enemy.x, enemy.y, enemy.viewDist, enemy.angle - enemy.fov/2, enemy.angle + enemy.fov/2);
            ctx.fill();

            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
            ctx.fill();
        });

        // Player
        ctx.fillStyle = player.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = player.color;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw Joystick UI
        if (joystick.active) {
            ctx.beginPath();
            ctx.arc(joystick.startX, joystick.startY, joystick.maxDist, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.stroke();
            
            ctx.beginPath();
            let jX = joystick.startX + (joystick.moveX * joystick.maxDist);
            let jY = joystick.startY + (joystick.moveY * joystick.maxDist);
            ctx.arc(jX, jY, 20, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
        }
    }

    function gameOver() {
        gameActive = false;
        finalScoreEl.innerText = score;
        gameOverScreen.style.display = 'block';
    }

    function resetGame(fullReset) {
        if (fullReset) {
            score = 0; level = 1;
            scoreEl.innerText = score; levelEl.innerText = level;
        }
        gameActive = true;
        gameOverScreen.style.display = 'none';
        initLevel();
        requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
        update();
        draw();
        if (gameActive) requestAnimationFrame(gameLoop);
    }

    initLevel();
    requestAnimationFrame(gameLoop);
</script>
</body>
</html>
